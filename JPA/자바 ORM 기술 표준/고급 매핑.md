## JPA

### **자바 ORM 기술 표준**

> 아래 글들은 인프런 **자바 ORM 표준 JPA 프로그래밍 - 기본편** 강의들 듣고 공부한 내용입니다.
>
> [강의 바로가기](

### 상속 관계 매핑

- 객체는 상속관계가 있는데 RDB에서는 상속 관계X 비슷하게 지원하는 DB도 있는데 객체의 상속관계와는 다르다

  하지만 슈퍼타입 서브타입 관계라는 모델링 기법이 객체의 상속관계와 유사하다.

- 상속관계 매핑 : 객체의 상속 구조와 DB의 슈퍼타입 서브타입 관계를 매핑 하는것.

  > RDB 설계에는 논리 모델과 물리 모델이 존재 한다.(어떤것인지 찾아보자.)

  **슈퍼타입 서브타입 논리 모델을 실제 물리 모델로 구현 하는 방법**

   1. 각각 테이블로 변환 -> 조인 전략

      - 데이터가 정교하게 모델링 할수 있고 JPA와 유사함.

   2. 통합 테이블로 변환 -> 단일 테이블 전략

      >Item에 book,movie,album을 상속관계만 놓고 실행하니 하나의 테이블에 만들어진것을 확인.
      >JPA의 기본적략 자체가 싱글테이블 전략으로 보여짐.

   3. 서브타입 테이블로 변환 -> 구현 클래스마다 테이블 전략

      > item 에 있는 가격 이런걸 하나로 싹다.

- 주요 어노테이션

  - @Inheritance(strategy=InheritanceType.XXX)

    - 3가지가 있는데 (JOINED , SINGLE_TABLE, TABLE,PER,CLASS)로 선택해서 테이블 전략을 할수 있다

      > ![image-20211003185436302](C:\Users\kopqw\AppData\Roaming\Typora\typora-user-images\image-20211003185436302.png)
      > default는 SINGLE_TABLE 이다.

  - @DiscriminatorColumn(name="TYPE")

    > <img src="C:\Users\kopqw\AppData\Roaming\Typora\typora-user-images\image-20211003185447549.png." alt="image-20211003185447549" style="zoom:80%;" />
    >
    > > default 는 DTYPE 
    > > <img src="C:\Users\kopqw\AppData\Roaming\Typora\typora-user-images\image-20211003185458470.png" alt="image-20211003185458470" style="zoom:80%;" />
    > >
    > > 실행 해보면 DTYPE생김.
    >
    > Entity명이 들어가게 된다.

  - @DiscriminatorValue("XXX")

    - 자식에 넣어주고 이름을 바꾸고 싶으면
    - `DiscriminatorColumn("A")` 이런식으로 바꾸면 된다.

  > 단일 테이블 전략으로 할때는 DYPE 으로 구분하면 됨. 그런데 단일 테이블로 해놓고 DiscriminatorColumn 사용하지 않아도 DTYPE은 만들어짐.

  **구현 클래스마다 테이블 전략 ** 값은 넣는거는 상관 없는데 찾을떄는 자식 을 모두다 뒤지면서 찾는다.

  | 전략             | 장점                                                         | 단점                                                         |
  | ---------------- | :----------------------------------------------------------- | ------------------------------------------------------------ |
  | 조인 전략        | 테이블 정규화 , 외래 키 참조 무결성 제약조건 활용 ,저장 공간 효율 | 조회시 조인을 많이 사용, 조회 쿼리가 복잡, 데이터 저장시 INSERT SQL 2번 호출 |
  | 단일 전략        | 조인이 필요 X , 조회 쿼리 단순                               | **자식 엔티티가 매핑한 컬럼은 모두 null 허용** , 테이블이 커지면 조회성능이 오히려 느려질수도 |
  | 구현 클래스 전략 | 서브 타입을 명확하게 구분해서 처리할때 효과적, not null 제약 조건 사용 가능. | 자식 테이블을 통합해서 쿼리하기 어려움.                      |

  > 조인 전략이 정석이라고 생각하고 들어가자, 객체랑도 잘맞고 정규화도 잘되고, 설계입장에서 깔끔.
  >
  > 단일 전략에서 특정 하나만 할때는 다른것은 필요 x기 떄문에 -> **null 허용**
  >
  > 구현 클래스 전략은 추천을 안한다고 함.

### @MappedSuperclass

- 공통 매핑 정보가 필요할때 사용(id, name)

  > 무슨 소리냐 만약 객체가 공통 속성을 가지고 있을떄 하나로 묶어서 사용한다고 보면 되는데
  >
  > ex) Member 에도 id , name  있고 Seller에도 id , name 이 있을때 사용
  >
  > 중복되는것이 많아 질수도 있는 경우가 생길때 속성만 받아서 사용하고 싶을때 사용 하는것이 **MappedSuperclass**다

```java
@MappedSuperclass
@Getter@Setter
public class BaseEntity {
	
    //컬럼 지정도 가능
    private String createdBy;
    private LocalDateTime createdData;
    //...
}
```

- 상속 관계 매핑 X 
- 엔티티 X 테이블과 매핑 X
- 부모 클래스을 상속 받는 **자식 클래스에 매핑 정보만 제공**
- 조회, 검색 불가(em.find(BaseEntity) 불가)
- 직접 생성해서 사용할 일이 없으므로 **추상 클래스 권장**

> 주로 등록일, 수정일 , 등록자, 수정자 같은 **전체 엔티티에서 공통**으로 적용하는 정보를 모을 때 사용.!!!
>
> **@Entity 상속관계 매핑일때만 사용 @MappedSuperclass 속성만 상속받을때 사용.**
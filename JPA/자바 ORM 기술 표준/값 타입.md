## JPA

### **자바 ORM 기술 표준**

> 아래 글들은 인프런 **자바 ORM 표준 JPA 프로그래밍 - 기본편** 강의들 듣고 공부한 내용입니다.
>
> [강의 바로가기](https://www.inflearn.com/course/ORM-JPA-Basic/dashboard)

---

### 기본 값 타입

JPA에는 2가지 데이터 타입으로 분류 할수 있다.

1. 엔티티 타입

   - @Entity로 정의하는 객체

   - 데이터가 변해도 식별자로 지속해서 추적 가능

     > 회원 Entity의 키나 나이 값을 변경해도 식별자로 인식 가능.

2. 값 타입

   - 자바 기본 타입이나 객체 (int,integer,String ...)
   - 식별자가 없고 값만 있으므로 변경시 추적 불가.

**값 타입** 안에는

- 기본값 타입

  - String name , int age ...
  - 생명주기를 Entity의 의존
    - 회원을 삭제하면 이름, 나이 필드도 함께 삭제
  - 값 타입은 공유 X
    - 회원 이름 변경시 다른 회원의 이름도 함께 변경되면 안됨
    - 기본 타입은 할상 값을 복사함.

- 임베디드 타입(embedded type, 복합 값 타입)

  - 새로운 값 타입을 직접 정의할 수 있음.

  - JPA는 임베디드 타입이라고 함.

  - 주로 기본 값 타입을 모아서 만들어서 복합 값 타입이라고도 함.

  - int, String과 같은 값 타입

    > 이것도 변경하면 끝.

  - JPA에서 사용하는법

    - @Embeddable : 값 타입을 정의하는 곳에 표시
    - @Embedded : 값 타입을 사용하는 곳에 표시
    - 기본 생성자 필수

  - **임베디드 타입을 사용하기 전과 후에 매핑하는 테이블은 같다.**

- 컬렉션 값 타입(collection value type)

  > 자바 컬렉션에 기본값이나 임베디드 타입 넣는것

**값 타입과 불변 객체**

- 임베디드 타입 같은 값 타입을 여러 Entity에서 공유하면 위험함.

- 부작용 발생.

  > 특정 값을 바꾸려고 했을때 같이 변경될수 있음.

- 대신 값을 복사해서 사용해야 한다.

  > `Address copyAddress = new Address(address.getCity(), address.getAddress(), address.getZipcode());` 이런식으로 전에 있던 값을 복사해서 넣어준다.
  >
  > 이렇게 하면 공유 참조로 인해 발생하는 부작용을 막을수는 있다.
  >
  > 문제는 임베디드 타입처럼 직접 정의한 값 타입은 자바의 기본 타입이 아니라 객체 타입 이다.

- 결론은 객체의 공유 참조는 피할 수 없다. 타입만 맞으면 다들어감. (=만 있으면)

**그럼 이런 것을 방지하려면**

- 객체 타입을 수정할 수 없게 만들면된다.

  - 값 타입은 불변 객체로 설계

    > 불변객체 : 생성 시점 이후 절대 값을 변경할 수 없는 객체.
    >
    > **생성자로만 값을 설정하고 Setter 만들지 않으면 됨.**

**값 타입의 비교**

- 동일성 비교 : 인스턴스의 참조 값을 비교 , == 사용

- 동등성 비교 : 인스턴스의 값을 비교. equals() 사용

  > 값타입의 비교는 equals 를 사용 해야 하는데 기본적으로 정의 되어 있는 equals말고 새로 새로 재정의 해서 사용하자.

**값 타입 컬렉션**

값 타입을 컬렉션에 담아서 사용하는것.

- 값 타입을 하나 이상 저장할 때 사용

- @ElementCollection, @CollectionTable을 사용해서.

- 데이터 베이스는 컬렉션을 같은 테이블에 저장할수 없다.

  > 컬렉션들은 1:N 이기 떄문에 별도에 테이블로 만들어 준다.
  >
  > 어떤 테이블에 어떤 연관관계가 있어야하는지 PK를 만들어줘야한다.

- 조회할때 자동적으로 지연로딩전략이 된다.

---

- 만들때 String 자체는 값타입이기 때문에 하면 X

**제약 사항**

- 값 타입 컬렉션에 변경 사항이 발생하면 , 주인 Entity와 연관된 모든 데이터를 삭제하고, 값 타입 걸렉션에 있는 현재 값을 모두 다시 저장한다.

  > 그러니까 컬렉션에 특정 값만 바꾼다고 했을때? 
  >
  > 그  entity에 있는 데이터를 다 날려버리고 바꾼 특정값만 insert 해버림.......

- 값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 기본키를 구성해야 함 

  > null 입력X 중복 저장 X

**위에 사항에 대한 대안**

- **일대다 관계를 위한 Entity를 만들고, 여기에 값 타입을 사용**

  > 새로운 클래스를 만들고 @Entity 한것을 사용. 

### 결론

엔티티 타입의 특징

- 식별자O
- 생명 주기 관리
- 공유

값 타입의 특징.

- 식별자X
- 생명 주기를 Entity에 의존
- 공유하지 않는 것이 안전(복사해서)
- 불변 객체로 만드는것이 안전.

> 식별자가 필요하고, 지속해서 값을 추적, 변경해야 한다면 그것은 값 타입이 아닌 Entity


## JPA

### **자바 ORM 기술 표준**

> 아래 글들은 인프런 **자바 ORM 표준 JPA 프로그래밍 - 기본편** 강의들 듣고 공부한 내용입니다.
>
> [강의 바로가기](https://www.inflearn.com/course/ORM-JPA-Basic/dashboard)


### JPA에서 가장 중요한 2가지

- 객체와 관계형 데이터베이스 매핑하기

- **영속성 컨텍스트** (JPA 내부에서 어떻게 동작하는지 알수 있게 됨)  /**JPA를 이해하는데 가장 중요한 용어**

  - 엔티티 매니저 팩토리 & 엔티티 매니저 를 알아야함.

  - 클라이언트의 요청이 올때마다 EntityManager를 생성되고,  만들어진 EntityManager는 내부적으로 DB커넥션을 통해 DB에 연결된다.

  - 한국어로 번역하면 **엔티티를 영구 저장하는 환경** 이라는 뜻. (EntityManager.persist(entity))

    > 그래서 전에 persist메서드를 이용해 DB에 저장한다고 생각했었는데, 그게 아니라 영속성 컨텍스트라는곳에 저장한다는 의미다.

    - 엔티티 매니저를 통해서 영속성 컨텍스트에 접근 ???

      > 간단하게 생각하면  EntityManager가 생성될때 영속성 컨텍스트가 생성된다.

  - 엔티티의 생명주기 

    - 비영속 ( new / transient)
      - 영속성 컨텍스트와 관계없는 **새로운 상태**, 최초 상태.
      - JPA와 위 방식은 아무 관계도 없으니까 비영속 관계
    - 영속 (managed) 코드에서 EntityManage.persist 해서 사용한것이 영속 상태
      - 영속성 컨텍스트에 **관리되는 상태**.
      - em.persist를 이용해서 영속성 컨텍스트 안에 member가 들어가 있는 상태를 영속 상태가 되는거임.
      - **이때는 DB에 저장이 안됨!**
    - 준영속 (detached)
      - 영속성 컨텍스트에 저장되었다가 **분리된 상태**
      - em.detach() 하면 영속성 컨텍스트에서 지워짐
    - 삭제 (removed)
      - **삭제된 상태**
      - em.remove() DB 삭제를 요청하는것.

  - 영속성 컨텍스트의 이점

    잘보면 애플리케이션이랑 DB 중간에 계층이 있는거로 볼수 있음.

    1. 엔티티 조회, 1차 캐시

       - em.persist() 를 하면 영속상태가 되는데 이떄 1차 캐시가 만들어짐.

         - | @id (키값) | Entity  |
           | ---------- | ------- |
           | "member 1" | member  |
           | "member 2" | member2 |

       - 키값과 멤버 자체가 Entity가 됨.

       - 이렇게 하면 **조회**할떄 편함. 

         ```java
         em.find(Member.class, "member1");
         ```

         DB에서 찾는게 아니라 1차 캐시부터 뒤지면서 찾음. 캐시에 있는값을 그대로 가져올수 있다. 

         > **그런데 만약 "member2"를 찾으라고 지시를 한다면? **
         >
         > 1차캐시에 "member2" 없음 -> DB 조회 (물론 DB에 "member2" 가 있어야함) -> 1차 캐시에 저장 -> member2 반환.

    2. 영속 엔티티의 동일성 보장

       > 같은거 확인하는거 보면됨. 대신 같은 트랜잭션안에서만 가능

    3. 엔티티 등록 (트랜잭션을 지원하는 쓰기 지연)

       ```java
       em.persist(memberA);
       em.persist(memberB);
       //아직 안보냄.
       
       //커밋하는 순간 데이터베이스에 INSERT SQL을 보냄.
       transaction.commit(); // 트랜젝션 커밋
       ```

       - persist하면 1차캐시에 들어가고, 동시에 JPA가 Entity를 분석해서 쓰기 지연 SQL저장소에 저장.

       - 이런식으로 memberB도 persist하면 똑같다.
       - 그다음에 transaction.commit() 을 하게 되면 commit 이 되고 쓰기 지연 SQL 저장소에 있던 애들이 flush가 되면서 실제 DB에 commit 됨.

    4. 엔티티 수정 ( 변경 감지 )

       - 값을 변경할때 내부적으로 flush를 하고 JPA가 Entity랑 스냅샷이랑 비교해서 Update에 커밋하고 그것을 보냄.

  - 준영속 상태

    - 영속 -> 준영속

      - 2가지의 영속성 컨텍스트에 넣을수 있음 (즉 영속 상태)

    - 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached)

      - em.defach() 

        > 영속성 컨텍스트에서 빼버리는것. -> 그게 준영속 상태 (특정 Entity만 준영속으로 바꿀때)

      - em.clear() 

        > 영속성 컨텍스트를 전부다 빼버리는것 

      - em.close() 

        > 영속성 컨텍스트를 닫아버리는것.

    - 영속성 컨텍스트가 제공하는 기능을 사용 못함.
### 스프링부트

> 아래 글들은 인프런 **스프링 핵심 원리 - 기본편** 강의를 듣고 공부한 내용입니다.
>
> [강의 가기](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/dashboard)

**좋은 객체 지향 설계 방법**

- SOLID : 로버트 마틴이 정의

  - SRP (Single responsibilty principle) 단일 책임 원칙

    - 한 클래스는 하나의 책임만 가져야한다.  -> 하지만 하나의 책임이라는것은 모호하다 클수도 있고 작을수도 있고, 문맥과 상황에 따라 다른데

    - **중요한 기준은 변경** 변경이 있을때 파급이 적으면 잘따른것  //잘한거는 변경이 있을때 하나의 클래스에서만 수정 떄리는것이 잘된것

      ex) UI를 변경을 하는데 sql부터 전부 다 고치면 잘못 배치 한것, 객체의 생성과 사용을 잘 분리 시키면 됨

  - OCP(Open/closed principle) 개방-폐쇠 원칙

    - 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있다. -> 확장을 하려면 기존 코드를 변경시켜야 하지 않나? 

    - 자바에서 **다형성** 을 활용하면 된다

    - 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현 -> 기존 코드를 변경하지 않으니까 확장은 열려있다.

      ex)

      ```java
      public class MemberService{
          private MemberRepo memberrepo = new MemberRepo();
      }
      -------------------------------------------------------
      public class MemverService{
          //private MemberRepo memberrepo = new MemberRepo(); 이걸 주석처리하고
          private MemverRepo memberrepo = new JdbcMemberrepo();
      }
      ```

      MemberService의 코드가 바뀐다.

    - 그래서 이러한 문제점이 있는데 위 코드를 보게될시 MemberService 클라이언트가 직접 구현클래스를 선택하고 있는걸 볼수있음. 이러면 클라이언트 코드를 변경해야한다.

  - DIP (Dependency inversion principle) 의존관계 역전 원칙

    - 프로그래머는 "추상화에 의존해야지, 구체화에 의존하면 안된다." 의존성 주입은 이 원칙을 따르는 방법 중 하나다 - > **쉽게 말하면 클라이언트 코드가 구현 클래스에 의존하지 말고, 인터페이스에만 의존하라는 뜻이다.**

    - 즉 역할과 구현을 철저히 구분해서 만들어야한다. 그래야 시스템도 적절히 갈아 끼울수 있다.

     > 쉽게 생각해보면

      ![image](https://user-images.githubusercontent.com/45530877/135711380-ed48942d-4283-4d91-bb2c-27518e1e826d.png)


      > 이그림으로 만들면 운전자는 자동차의 역할에대해서만 알아야한다.

      ![image](https://user-images.githubusercontent.com/45530877/135711343-c69d9ddc-e318-48e3-aa12-4396dd63d583.png)

      >  이런식으로 봤을때는 A라는 사람이 C하고만 역할을 맞아서 했는데 그래서 C하고만 역할을 맞아 연습이 가능함
      >
      >  그런데 여기서 D로 역할이 바뀌면 대체 가능성이 없어지지?

**문제점**

- 역활과 구현은 분리 OK

- 다형성 활용, 인터페이스와 구현 객체를 분리 OK

- OCP, DIP 같은 객체지향 설계 원칙을 준수 - X

  - **DIP** : 주문 서비스 클라이언트(`OrderServiceImpl`)는(`DiscountPolicy`)인터페이스에 의존하는 형식으로 보일수 있음

  - 의존 관게를 분석해보면 **인터페이스 뿐만 아니라 구현클래스에도 의존**하고있는것을 볼수있다.

    - 인터페이스 의존 : `DiscountPolicy`

    - 구현 클래스 : `FixDicountPolicy`, `RateDiscountPolicy`

      ![image](https://user-images.githubusercontent.com/45530877/135711337-e3b8062a-4d5f-477a-8a39-88141b04537a.png)

      이런식으로 FixDiscountPolicy도 실제코드에서는 의존하고있다.

      ```java
      public class OrtderServiceImpl implements OrderService{
      
          private final MemberRepo memberRepo = new MemberMemoryRepo();
          private final DiscountPolicy discountPolicy = new FixDiscountPolicy();
      ```

    - 그런데 여기서 정책 까지 바꾼다고 하면 

      ![image](https://user-images.githubusercontent.com/45530877/135711328-729c3adb-8772-40ab-b8a8-c3160adcadef.png)

      ```java
      private final MemberRepo memberRepo = new MemberMemoryRepo();
      //private final DiscountPolicy discountPolicy = new FixDiscountPolicy();
      private final DiscountPolicy discountPolicy = new RateDiscountPolicy();
      ```

      - `FixDiscountPolicy`를 뺴고 `RateDiscountPolicy`로 바꾸는 순간 `OrderServiceImpl`의 코드도 바뀌게 되면서 **OCP** 위반을 하게된다.

  - 해결방법

    - 인터페이스에만 의존하도록 설계를 변경한다.

    - 그러나 아래 방법으로 하면 **NPE**뜸 

      > discountPolicy 에 아무것도 할당도 안했는데 뭘 하려고해서

      ```java
      private DiscountPolicy discountPolicy;
       // private final DiscountPolicy discountPolicy = new FixDiscountPolicy();
       // private final DiscountPolicy discountPolicy = new RateDiscountPolicy();
      ```

    - 클라이언트인 `OrderServiceImpl`에 `DiscountPolicy`의 구현 객체를 대신 생성하고 주입하면 해결

    - 실제 실행되는 객체들은 본인의 역할만 수행하게 해줘야한다. 어떤 구현체들이 인터페이스에 할당되는것은 Config가 담당한다.

    - 그래서 어플리케이션의 전체 동작 방식을 Config하기 위해, **구현 객체를 생성** 하고, **연결** 하는 책임을 가지는 별도의 설정 클래스를 만들어야함.

  - AppConfig는 어플리케이션의 실제 동작에 필요한 **구현 객체를 생성**하게된다. 그리고 그것을  생성자를 통해서 주입

    > 주입한다는 의미는 간단하게 보면 그냥 Appconfig에서 `new MemberMemoryRepo()`를 참조값을 `MemberServiceImpl`여기에 넣어주는것을 의미한다

    - `MemberServiceImpl` -> `MeberMemoryRepo()`    주입
    - `OrderServiceImpl` -> `MemberMemoryRepo()`, `FixDiscountPolicy()`  주입

    ```java
    //AppConfig 클래스
    //생성자 주입
    public class AppConfig {
        public MemberService memberService(){
            return new MemberServiceImpl(new MemberMemoryRepo());
        }
        public OrderService orderService(){
            return new OrderServiceImpl(new MemberMemoryRepo(),new FixDiscountPolicy());
        }
    }
    ```

    ```java
    //OrderServiceImpl 클래스
    public class OrderServiceImpl implements OrderService{
    
        private final MemberRepo memberRepo;
        private final DiscountPolicy discountPolicy;
    
        public OrderServiceImpl(MemberRepo memberRepo, DiscountPolicy discountPolicy) {
            this.memberRepo = memberRepo;
            this.discountPolicy = discountPolicy;
        }
        
    ```

  - `OrderServiceImpl`

    > 어떤 구현객체가 들어올지 AppConfig 를 통해서만 결정된다는것만 제대로 알아두자.

    ![image](https://user-images.githubusercontent.com/45530877/135711307-36559f96-4199-46b1-9e10-0226df041a14.png)

    의존관계를 마치외부에서 넣어주는거 같다고 해서 DI (Depencency Injection) 의존성 주입이라고 한다.

#### 정리

- AppConfig를 통해서 관심사를 확실하게 분리.

- AppConfig 전체적으로 기획하는거라고 생각.

- AppConfig가 이제 구체 클래스를 선택하고 전체적으로 책임.

- 그럼 이제 담당 기능들은 실행만 하게 되는것.

  >  `OrderServiceImpl`은 실행하는 것만 하면 되는것이다.